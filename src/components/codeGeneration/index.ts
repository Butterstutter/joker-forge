import { JokerData } from "../JokerCard";
import JSZip from "jszip";
import { addAtlasToZip } from "./ImageProcessor";
import { generateTriggerContext } from "./triggerUtils";
import { generateConditionChain } from "./conditionUtils";
import {
  generateEffectReturnStatement,
  processPassiveEffects,
} from "./effectUtils";
import {
  extractVariablesFromRules,
  generateVariableConfig,
  getAllVariables,
  extractGameVariablesFromRules,
} from "./variableUtils";
import type { Rule } from "../ruleBuilder/types";
import type { PassiveEffectResult } from "./effectUtils";
import { parseGameVariable, parseRangeVariable } from "./gameVariableUtils";
import { generateDiscountItemsHook } from "./effects/DiscountItemsEffect";
import { generateReduceFlushStraightRequirementsHook } from "./effects/ReduceFlushStraightRequirementsEffect";
import { generateShortcutHook } from "./effects/ShortcutEffect";

export interface ModMetadata {
  id: string;
  name: string;
  author: string[];
  description: string;
  prefix: string;
  main_file: string;
  version: string;
  priority: number;
  badge_colour: string;
  badge_text_colour: string;
  display_name: string;
  dependencies: string[];
  conflicts: string[];
  provides: string[];
  dump_loc?: boolean;
}

interface EffectVariableMapping {
  [effectId: string]: string;
}

let globalEffectVariableMapping: EffectVariableMapping = {};

const convertRandomGroupsForCodegen = (
  randomGroups: import("../ruleBuilder/types").RandomGroup[]
) => {
  return randomGroups.map((group) => ({
    ...group,
    chance_numerator:
      typeof group.chance_numerator === "string" ? 1 : group.chance_numerator,
    chance_denominator:
      typeof group.chance_denominator === "string"
        ? 1
        : group.chance_denominator,
  }));
};

const generateLuaCode = (
  jokers: JokerData[],
  options: {
    modPrefix?: string;
    isSingleJoker?: boolean;
    includeAtlas?: boolean;
    atlasKey?: string;
  } = {}
): string => {
  const {
    modPrefix = "",
    isSingleJoker = false,
    includeAtlas = true,
    atlasKey = "CustomJokers",
  } = options;

  let output = `-- FILE GENERATED BY JOKER FORGE
-- ** If you find any bugs, or have suggestions, please report them on the GitHub repository: https://github.com/Jayd-H/joker-forge/issues **

`;

  if (includeAtlas) {
    output += `-- Atlas
SMODS.Atlas({
    key = "${atlasKey}", 
    path = "${atlasKey}.png", 
    px = 71,
    py = 95, 
    atlas_table = "ASSET_ATLAS"
}):register()

`;
  }

  globalEffectVariableMapping = {};

  jokers.forEach((joker, index) => {
    if (isSingleJoker) {
      const passiveEffects = processPassiveEffects(joker);
      let jokerCode = generateSingleJokerBase(joker, passiveEffects);

      const locVarsCode = generateLocVarsFunction(joker, passiveEffects);
      jokerCode += `,\n\n    ${locVarsCode}`;

      const setStickerCode = generateSetAbilityFunction(joker);
      if (setStickerCode) {
        jokerCode += `,\n\n    ${setStickerCode}`;
      }

      const nonPassiveRules =
        joker.rules?.filter((rule) => rule.trigger !== "passive") || [];
      if (nonPassiveRules.length > 0) {
        const calculateCode = generateCalculateFunction(nonPassiveRules, joker);
        jokerCode += `,\n\n    ${calculateCode}`;
      }

      passiveEffects.forEach((effect) => {
        if (effect.addToDeck) {
          jokerCode += `,\n\n    add_to_deck = function(self, card, from_debuff)
        ${effect.addToDeck}
    end`;
        }

        if (effect.removeFromDeck) {
          jokerCode += `,\n\n    remove_from_deck = function(self, card, from_debuff)
        ${effect.removeFromDeck}
    end`;
        }
      });

      jokerCode += `\n}`;
      output += jokerCode;
    } else {
      output += generateJokerCode(joker, index, atlasKey, jokers) + "\n\n";
    }
  });

  if (modPrefix) {
    const hookCode = generateHooks(jokers, modPrefix);
    if (hookCode.trim()) {
      output += (isSingleJoker ? "\n" : "") + hookCode;
    }
  }

  return output.trim();
};

export const exportJokersAsMod = async (
  jokers: JokerData[],
  metadata: ModMetadata
): Promise<boolean> => {
  try {
    const zip = new JSZip();

    const luaCode = generateLuaCode(jokers, {
      modPrefix: metadata.prefix,
      isSingleJoker: false,
      includeAtlas: true,
      atlasKey: "CustomJokers",
    });

    zip.file(metadata.main_file, luaCode);
    zip.file(`${metadata.id}.json`, generateModJson(metadata));
    zip.file("config.lua", "return {}");

    await addAtlasToZip(zip, jokers);

    console.log(jokers);

    const content = await zip.generateAsync({ type: "blob" });
    const url = URL.createObjectURL(content);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${metadata.id}.zip`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    return true;
  } catch (error) {
    console.error("Failed to generate mod:", error);
    return false;
  }
};

export const exportSingleJoker = (joker: JokerData): void => {
  try {
    const jokerCode = generateLuaCode([joker], {
      modPrefix: "",
      isSingleJoker: true,
      includeAtlas: false,
      atlasKey: "Joker",
    });

    const blob = new Blob([jokerCode], { type: "text/plain" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${slugify(joker.name)}.lua`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  } catch (error) {
    console.error("Failed to export joker:", error);
    throw error;
  }
};

const generateJokerCode = (
  joker: JokerData,
  index: number,
  atlasKey: string,
  allJokers: JokerData[]
): string => {
  const passiveEffects = processPassiveEffects(joker);

  let jokerCode = generateJokerBase(
    joker,
    index,
    atlasKey,
    passiveEffects,
    allJokers
  );

  const locVarsCode = generateLocVarsFunction(joker, passiveEffects);
  jokerCode += `,\n\n    ${locVarsCode}`;

  const setStickerCode = generateSetAbilityFunction(joker);
  if (setStickerCode) {
    jokerCode += `,\n\n    ${setStickerCode}`;
  }

  const nonPassiveRules =
    joker.rules?.filter((rule) => rule.trigger !== "passive") || [];

  if (nonPassiveRules.length > 0) {
    const calculateCode = generateCalculateFunction(nonPassiveRules, joker);
    jokerCode += `,\n\n    ${calculateCode}`;
  }

  passiveEffects.forEach((effect) => {
    if (effect.addToDeck) {
      jokerCode += `,\n\n    add_to_deck = function(self, card, from_debuff)
        ${effect.addToDeck}
    end`;
    }

    if (effect.removeFromDeck) {
      jokerCode += `,\n\n    remove_from_deck = function(self, card, from_debuff)
        ${effect.removeFromDeck}
    end`;
    }

    if (effect.calculateFunction) {
      jokerCode += `,\n\n    ${effect.calculateFunction}`;
    }
  });

  jokerCode += `\n}`;
  return jokerCode;
};

const generateSetAbilityFunction = (joker: JokerData): string | null => {
  const forcedStickers: string[] = [];
  const suitVariables = (joker.userVariables || []).filter(
    (v) => v.type === "suit"
  );
  const rankVariables = (joker.userVariables || []).filter(
    (v) => v.type === "rank"
  );
  const pokerHandVariables = (joker.userVariables || []).filter(
    (v) => v.type === "pokerhand"
  );

  if (joker.force_eternal) {
    forcedStickers.push("card:set_eternal(true)");
  }

  if (joker.force_perishable) {
    forcedStickers.push("card:add_sticker('perishable', true)");
  }

  if (joker.force_rental) {
    forcedStickers.push("card:add_sticker('rental', true)");
  }

  const variableInits: string[] = [];

  suitVariables.forEach((variable) => {
    const defaultSuit = variable.initialSuit || "Spades";
    variableInits.push(
      `G.GAME.current_round.${variable.name}_card = { suit = '${defaultSuit}' }`
    );
  });

  rankVariables.forEach((variable) => {
    const defaultRank = variable.initialRank || "Ace";
    const defaultId = getRankId(defaultRank);
    variableInits.push(
      `G.GAME.current_round.${variable.name}_card = { rank = '${defaultRank}', id = ${defaultId} }`
    );
  });

  pokerHandVariables.forEach((variable) => {
    const defaultPokerHand = variable.initialPokerHand || "High Card";
    variableInits.push(
      `G.GAME.current_round.${variable.name}_hand = '${defaultPokerHand}'`
    );
  });

  if (forcedStickers.length === 0 && variableInits.length === 0) {
    return null;
  }

  const allCode = [...forcedStickers, ...variableInits];

  return `set_ability = function(self, card, initial)
        ${allCode.join("\n        ")}
    end`;
};

const getRankId = (rank: string): number => {
  switch (rank) {
    case "Ace":
      return 14;
    case "King":
      return 13;
    case "Queen":
      return 12;
    case "Jack":
      return 11;
    default:
      return parseInt(rank) || 14;
  }
};

const generateSingleJokerBase = (
  joker: JokerData,
  passiveEffects: PassiveEffectResult[]
): string => {
  globalEffectVariableMapping = {};
  const effectsConfig = extractEffectsConfig(joker, passiveEffects);

  let jokerCode = `-- FILE GENERATED BY JOKER FORGE

SMODS.Joker{ --${joker.name}
    name = "${joker.name}",
    key = "${slugify(joker.name)}",
    config = {
        extra = {`;

  if (effectsConfig.trim()) {
    jokerCode += `
            ${effectsConfig}`;
  }

  jokerCode += `
        }
    },
    loc_txt = {
        ['name'] = '${joker.name}',
        ['text'] = ${formatJokerDescription(joker)}
    },
    pos = {
        x = 0,
        y = 0
    },
    cost = ${joker.cost !== undefined ? joker.cost : 4},
    rarity = ${joker.rarity},
    blueprint_compat = ${
      joker.blueprint_compat !== undefined ? joker.blueprint_compat : true
    },
    eternal_compat = ${
      joker.eternal_compat !== undefined ? joker.eternal_compat : true
    },
    unlocked = ${joker.unlocked !== undefined ? joker.unlocked : true},
    discovered = ${joker.discovered !== undefined ? joker.discovered : true},
    atlas = 'Joker'`;

  if (joker.overlayImagePreview) {
    jokerCode += `,
    soul_pos = {
        x = 1,
        y = 0
    }`;
  }

  if (
    (joker.rarity !== 4 && joker.appears_in_shop === false) ||
    (joker.rarity === 4 && joker.appears_in_shop === true)
  ) {
    jokerCode += `,

    in_pool = function(self, args)
        return ${
          joker.rarity === 4 && joker.appears_in_shop === true
            ? "true"
            : "false"
        }
    end`;
  }

  return jokerCode;
};

const generateJokerBase = (
  joker: JokerData,
  index: number,
  atlasKey: string,
  passiveEffects: PassiveEffectResult[],
  allJokers: JokerData[]
): string => {
  let totalSlotsUsed = 0;
  for (let i = 0; i < index; i++) {
    totalSlotsUsed += allJokers[i].overlayImagePreview ? 2 : 1;
  }

  const x = totalSlotsUsed % 10;
  const y = Math.floor(totalSlotsUsed / 10);

  globalEffectVariableMapping = {};
  const effectsConfig = extractEffectsConfig(joker, passiveEffects);

  let jokerCode = `SMODS.Joker{ --${joker.name}
    name = "${joker.name}",
    key = "${slugify(joker.name)}",
    config = {
        extra = {`;

  if (effectsConfig.trim()) {
    jokerCode += `
            ${effectsConfig}`;
  }

  jokerCode += `
        }
    },
    loc_txt = {
        ['name'] = '${joker.name}',
        ['text'] = ${formatJokerDescription(joker)}
    },
    pos = {
        x = ${x},
        y = ${y}
    },
    cost = ${joker.cost !== undefined ? joker.cost : 4},
    rarity = ${joker.rarity},
    blueprint_compat = ${
      joker.blueprint_compat !== undefined ? joker.blueprint_compat : true
    },
    eternal_compat = ${
      joker.eternal_compat !== undefined ? joker.eternal_compat : true
    },
    unlocked = ${joker.unlocked !== undefined ? joker.unlocked : true},
    discovered = ${joker.discovered !== undefined ? joker.discovered : true},
    atlas = '${atlasKey}'`;

  if (joker.overlayImagePreview) {
    const soulX = (totalSlotsUsed + 1) % 10;
    const soulY = Math.floor((totalSlotsUsed + 1) / 10);
    jokerCode += `,
    soul_pos = {
        x = ${soulX},
        y = ${soulY}
    }`;
  }

  if (
    (joker.rarity !== 4 && joker.appears_in_shop === false) ||
    (joker.rarity === 4 && joker.appears_in_shop === true)
  ) {
    jokerCode += `,

    in_pool = function(self, args)
        return ${
          joker.rarity === 4 && joker.appears_in_shop === true
            ? "true"
            : "false"
        }
    end`;
  }

  return jokerCode;
};

const extractEffectsConfig = (
  joker: JokerData,
  passiveEffects: PassiveEffectResult[]
): string => {
  const configItems: string[] = [];
  const variableCountByType: Record<string, number> = {};

  const getUniqueVariableName = (baseName: string): string => {
    if (variableCountByType[baseName] === undefined) {
      variableCountByType[baseName] = 0;
      return baseName;
    } else {
      variableCountByType[baseName]++;
      return `${baseName}${variableCountByType[baseName]}`;
    }
  };

  const allVariableNames = new Set<string>();
  if (joker.userVariables) {
    joker.userVariables.forEach((v) => allVariableNames.add(v.name));
  }

  passiveEffects.forEach((effect) => {
    if (effect.configVariables) {
      effect.configVariables.forEach((configVar) => {
        if (configVar.trim()) {
          configItems.push(configVar);
        }
      });
    }
  });

  if (joker.userVariables && joker.userVariables.length > 0) {
    joker.userVariables.forEach((variable) => {
      if (variable.type === "number" || !variable.type) {
        configItems.push(`${variable.name} = ${variable.initialValue || 0}`);
      }
    });
  }

  const gameVariables = extractGameVariablesFromRules(joker.rules || []);
  gameVariables.forEach((gameVar) => {
    const varName = gameVar.name.replace(/\s+/g, "").toLowerCase();
    configItems.push(`${varName} = ${gameVar.startsFrom}`);
  });

  if (joker.rules && joker.rules.length > 0) {
    const nonPassiveRules = joker.rules.filter(
      (rule) => rule.trigger !== "passive"
    );
    const variables = extractVariablesFromRules(nonPassiveRules);

    const userVariableNames = new Set(
      joker.userVariables?.map((v) => v.name) || []
    );
    const autoVariables = variables.filter(
      (v) => !userVariableNames.has(v.name)
    );

    if (autoVariables.length > 0) {
      const variableConfig = generateVariableConfig(autoVariables);
      if (variableConfig) {
        configItems.push(variableConfig);
      }
    }

    const hasRandomGroups = nonPassiveRules.some(
      (rule) => rule.randomGroups && rule.randomGroups.length > 0
    );

    if (hasRandomGroups) {
      const randomGroups = nonPassiveRules.flatMap(
        (rule) => rule.randomGroups || []
      );
      if (randomGroups.length > 0) {
        const denominators = [
          ...new Set(randomGroups.map((group) => group.chance_denominator)),
        ];
        if (denominators.length === 1) {
          configItems.push(`odds = ${denominators[0]}`);
        } else {
          denominators.forEach((denom, index) => {
            if (index === 0) {
              configItems.push(`odds = ${denom}`);
            } else {
              configItems.push(`odds${index + 1} = ${denom}`);
            }
          });
        }
      }
    }

    nonPassiveRules.forEach((rule) => {
      (rule.effects || []).forEach((effect) => {
        const effectValue = effect.params.value;
        const parsed = parseGameVariable(effectValue);
        const rangeParsed = parseRangeVariable(effectValue);

        if (parsed.isGameVariable || rangeParsed.isRangeVariable) {
          if (rangeParsed.isRangeVariable) {
            const varName = getUniqueVariableName(
              effect.type === "add_chips"
                ? "chips"
                : effect.type === "add_mult"
                ? "mult"
                : effect.type === "apply_x_mult"
                ? "Xmult"
                : effect.type === "add_dollars"
                ? "dollars"
                : effect.type === "apply_x_chips"
                ? "xchips"
                : effect.type === "apply_exp_mult"
                ? "emult"
                : effect.type === "apply_exp_chips"
                ? "echips"
                : effect.type === "set_dollars"
                ? "set_dollars"
                : effect.type === "add_sell_value"
                ? "sell_value"
                : "value"
            );
            configItems.push(`${varName}_min = ${rangeParsed.min}`);
            configItems.push(`${varName}_max = ${rangeParsed.max}`);
            globalEffectVariableMapping[effect.id] = varName;
          }
          return;
        }

        if (
          effect.type === "add_chips" &&
          typeof effectValue === "number" &&
          !allVariableNames.has(String(effectValue))
        ) {
          const varName = getUniqueVariableName("chips");
          configItems.push(`${varName} = ${effectValue}`);
          globalEffectVariableMapping[effect.id] = varName;
        }

        if (
          effect.type === "add_mult" &&
          typeof effectValue === "number" &&
          !allVariableNames.has(String(effectValue))
        ) {
          const varName = getUniqueVariableName("mult");
          configItems.push(`${varName} = ${effectValue}`);
          globalEffectVariableMapping[effect.id] = varName;
        }

        if (
          effect.type === "apply_x_mult" &&
          typeof effectValue === "number" &&
          !allVariableNames.has(String(effectValue))
        ) {
          const varName = getUniqueVariableName("Xmult");
          configItems.push(`${varName} = ${effectValue}`);
          globalEffectVariableMapping[effect.id] = varName;
        }

        if (
          effect.type === "add_dollars" &&
          typeof effectValue === "number" &&
          !allVariableNames.has(String(effectValue))
        ) {
          const varName = getUniqueVariableName("dollars");
          configItems.push(`${varName} = ${effectValue}`);
          globalEffectVariableMapping[effect.id] = varName;
        }

        if (effect.type === "retrigger_cards") {
          const repetitions = effect.params.repetitions || 1;
          const parsedRepetitions = parseGameVariable(repetitions);
          const rangeParsedRepetitions = parseRangeVariable(repetitions);

          if (
            parsedRepetitions.isGameVariable ||
            rangeParsedRepetitions.isRangeVariable
          ) {
            if (rangeParsedRepetitions.isRangeVariable) {
              const varName = getUniqueVariableName("repetitions");
              configItems.push(
                `${varName}_min = ${rangeParsedRepetitions.min}`
              );
              configItems.push(
                `${varName}_max = ${rangeParsedRepetitions.max}`
              );
              globalEffectVariableMapping[effect.id] = varName;
            }
            return;
          }

          const varName = getUniqueVariableName("repetitions");
          configItems.push(`${varName} = ${repetitions}`);
          globalEffectVariableMapping[effect.id] = varName;
        }

        if (effect.type === "edit_hand") {
          const value = effect.params.value || 1;
          const parsedValue = parseGameVariable(value);
          const rangeParsedValue = parseRangeVariable(value);

          if (parsedValue.isGameVariable || rangeParsedValue.isRangeVariable) {
            if (rangeParsedValue.isRangeVariable) {
              const varName = getUniqueVariableName("hands");
              configItems.push(`${varName}_min = ${rangeParsedValue.min}`);
              configItems.push(`${varName}_max = ${rangeParsedValue.max}`);
              globalEffectVariableMapping[effect.id] = varName;
            }
            return;
          }

          const varName = getUniqueVariableName("hands");
          configItems.push(`${varName} = ${value}`);
          globalEffectVariableMapping[effect.id] = varName;
        }

        if (effect.type === "edit_discard") {
          const value = effect.params.value || 1;
          const parsedValue = parseGameVariable(value);
          const rangeParsedValue = parseRangeVariable(value);

          if (parsedValue.isGameVariable || rangeParsedValue.isRangeVariable) {
            if (rangeParsedValue.isRangeVariable) {
              const varName = getUniqueVariableName("discards");
              configItems.push(`${varName}_min = ${rangeParsedValue.min}`);
              configItems.push(`${varName}_max = ${rangeParsedValue.max}`);
              globalEffectVariableMapping[effect.id] = varName;
            }
            return;
          }

          const varName = getUniqueVariableName("discards");
          configItems.push(`${varName} = ${value}`);
          globalEffectVariableMapping[effect.id] = varName;
        }

        if (effect.type === "level_up_hand") {
          const value = effect.params.value || 1;
          const parsedValue = parseGameVariable(value);
          const rangeParsedValue = parseRangeVariable(value);

          if (parsedValue.isGameVariable || rangeParsedValue.isRangeVariable) {
            if (rangeParsedValue.isRangeVariable) {
              const varName = getUniqueVariableName("levels");
              configItems.push(`${varName}_min = ${rangeParsedValue.min}`);
              configItems.push(`${varName}_max = ${rangeParsedValue.max}`);
              globalEffectVariableMapping[effect.id] = varName;
            }
            return;
          }

          const varName = getUniqueVariableName("levels");
          configItems.push(`${varName} = ${value}`);
          globalEffectVariableMapping[effect.id] = varName;
        }

        if (
          effect.type === "apply_x_chips" &&
          typeof effectValue === "number" &&
          !allVariableNames.has(String(effectValue))
        ) {
          const varName = getUniqueVariableName("xchips");
          configItems.push(`${varName} = ${effectValue}`);
          globalEffectVariableMapping[effect.id] = varName;
        }

        if (
          effect.type === "apply_exp_mult" &&
          typeof effectValue === "number" &&
          !allVariableNames.has(String(effectValue))
        ) {
          const varName = getUniqueVariableName("emult");
          configItems.push(`${varName} = ${effectValue}`);
          globalEffectVariableMapping[effect.id] = varName;
        }

        if (
          effect.type === "apply_exp_chips" &&
          typeof effectValue === "number" &&
          !allVariableNames.has(String(effectValue))
        ) {
          const varName = getUniqueVariableName("echips");
          configItems.push(`${varName} = ${effectValue}`);
          globalEffectVariableMapping[effect.id] = varName;
        }

        if (
          effect.type === "set_dollars" &&
          typeof effectValue === "number" &&
          !allVariableNames.has(String(effectValue))
        ) {
          const varName = getUniqueVariableName("set_dollars");
          configItems.push(`${varName} = ${effectValue}`);
          globalEffectVariableMapping[effect.id] = varName;
        }

        if (effect.type === "add_sell_value") {
          const effectValue = effect.params.value;
          const parsed = parseGameVariable(effectValue);
          const rangeParsed = parseRangeVariable(effectValue);

          if (parsed.isGameVariable || rangeParsed.isRangeVariable) {
            if (rangeParsed.isRangeVariable) {
              const varName = getUniqueVariableName("sell_value");
              configItems.push(`${varName}_min = ${rangeParsed.min}`);
              configItems.push(`${varName}_max = ${rangeParsed.max}`);
              globalEffectVariableMapping[effect.id] = varName;
            }
            return;
          }

          if (
            typeof effectValue === "number" &&
            !allVariableNames.has(String(effectValue))
          ) {
            const varName = getUniqueVariableName("sell_value");
            configItems.push(`${varName} = ${effectValue}`);
            globalEffectVariableMapping[effect.id] = varName;
          }
        }

        if (effect.type === "set_ante") {
          const value = effect.params.value;
          const parsedValue = parseGameVariable(value);
          const rangeParsedValue = parseRangeVariable(value);

          if (parsedValue.isGameVariable || rangeParsedValue.isRangeVariable) {
            if (rangeParsedValue.isRangeVariable) {
              const varName = getUniqueVariableName("ante_value");
              configItems.push(`${varName}_min = ${rangeParsedValue.min}`);
              configItems.push(`${varName}_max = ${rangeParsedValue.max}`);
              globalEffectVariableMapping[effect.id] = varName;
            }
            return;
          }

          if (
            typeof value === "number" &&
            !allVariableNames.has(String(value))
          ) {
            const varName = getUniqueVariableName("ante_value");
            configItems.push(`${varName} = ${value}`);
            globalEffectVariableMapping[effect.id] = varName;
          }
        }
      });

      (rule.randomGroups || []).forEach((group) => {
        group.effects.forEach((effect) => {
          const effectValue = effect.params.value;
          const parsed = parseGameVariable(effectValue);
          const rangeParsed = parseRangeVariable(effectValue);

          if (parsed.isGameVariable || rangeParsed.isRangeVariable) {
            if (rangeParsed.isRangeVariable) {
              const varName = getUniqueVariableName(
                effect.type === "add_chips"
                  ? "chips"
                  : effect.type === "add_mult"
                  ? "mult"
                  : effect.type === "apply_x_mult"
                  ? "Xmult"
                  : effect.type === "add_dollars"
                  ? "dollars"
                  : effect.type === "apply_x_chips"
                  ? "xchips"
                  : effect.type === "apply_exp_mult"
                  ? "emult"
                  : effect.type === "apply_exp_chips"
                  ? "echips"
                  : effect.type === "set_dollars"
                  ? "set_dollars"
                  : effect.type === "add_sell_value"
                  ? "sell_value"
                  : "value"
              );
              configItems.push(`${varName}_min = ${rangeParsed.min}`);
              configItems.push(`${varName}_max = ${rangeParsed.max}`);
              globalEffectVariableMapping[effect.id] = varName;
            }
            return;
          }

          if (
            effect.type === "add_chips" &&
            typeof effectValue === "number" &&
            !allVariableNames.has(String(effectValue))
          ) {
            const varName = getUniqueVariableName("chips");
            configItems.push(`${varName} = ${effectValue}`);
            globalEffectVariableMapping[effect.id] = varName;
          }

          if (
            effect.type === "add_mult" &&
            typeof effectValue === "number" &&
            !allVariableNames.has(String(effectValue))
          ) {
            const varName = getUniqueVariableName("mult");
            configItems.push(`${varName} = ${effectValue}`);
            globalEffectVariableMapping[effect.id] = varName;
          }

          if (
            effect.type === "apply_x_mult" &&
            typeof effectValue === "number" &&
            !allVariableNames.has(String(effectValue))
          ) {
            const varName = getUniqueVariableName("Xmult");
            configItems.push(`${varName} = ${effectValue}`);
            globalEffectVariableMapping[effect.id] = varName;
          }

          if (
            effect.type === "add_dollars" &&
            typeof effectValue === "number" &&
            !allVariableNames.has(String(effectValue))
          ) {
            const varName = getUniqueVariableName("dollars");
            configItems.push(`${varName} = ${effectValue}`);
            globalEffectVariableMapping[effect.id] = varName;
          }

          if (effect.type === "retrigger_cards") {
            const repetitions = effect.params.repetitions || 1;
            const parsedRepetitions = parseGameVariable(repetitions);
            const rangeParsedRepetitions = parseRangeVariable(repetitions);

            if (
              parsedRepetitions.isGameVariable ||
              rangeParsedRepetitions.isRangeVariable
            ) {
              if (rangeParsedRepetitions.isRangeVariable) {
                const varName = getUniqueVariableName("repetitions");
                configItems.push(
                  `${varName}_min = ${rangeParsedRepetitions.min}`
                );
                configItems.push(
                  `${varName}_max = ${rangeParsedRepetitions.max}`
                );
                globalEffectVariableMapping[effect.id] = varName;
              }
              return;
            }

            const varName = getUniqueVariableName("repetitions");
            configItems.push(`${varName} = ${repetitions}`);
            globalEffectVariableMapping[effect.id] = varName;
          }

          if (effect.type === "edit_hand") {
            const value = effect.params.value || 1;
            const parsedValue = parseGameVariable(value);
            const rangeParsedValue = parseRangeVariable(value);

            if (
              parsedValue.isGameVariable ||
              rangeParsedValue.isRangeVariable
            ) {
              if (rangeParsedValue.isRangeVariable) {
                const varName = getUniqueVariableName("hands");
                configItems.push(`${varName}_min = ${rangeParsedValue.min}`);
                configItems.push(`${varName}_max = ${rangeParsedValue.max}`);
                globalEffectVariableMapping[effect.id] = varName;
              }
              return;
            }

            const varName = getUniqueVariableName("hands");
            configItems.push(`${varName} = ${value}`);
            globalEffectVariableMapping[effect.id] = varName;
          }

          if (effect.type === "edit_discard") {
            const value = effect.params.value || 1;
            const parsedValue = parseGameVariable(value);
            const rangeParsedValue = parseRangeVariable(value);

            if (
              parsedValue.isGameVariable ||
              rangeParsedValue.isRangeVariable
            ) {
              if (rangeParsedValue.isRangeVariable) {
                const varName = getUniqueVariableName("discards");
                configItems.push(`${varName}_min = ${rangeParsedValue.min}`);
                configItems.push(`${varName}_max = ${rangeParsedValue.max}`);
                globalEffectVariableMapping[effect.id] = varName;
              }
              return;
            }

            const varName = getUniqueVariableName("discards");
            configItems.push(`${varName} = ${value}`);
            globalEffectVariableMapping[effect.id] = varName;
          }

          if (effect.type === "level_up_hand") {
            const value = effect.params.value || 1;
            const parsedValue = parseGameVariable(value);
            const rangeParsedValue = parseRangeVariable(value);

            if (
              parsedValue.isGameVariable ||
              rangeParsedValue.isRangeVariable
            ) {
              if (rangeParsedValue.isRangeVariable) {
                const varName = getUniqueVariableName("levels");
                configItems.push(`${varName}_min = ${rangeParsedValue.min}`);
                configItems.push(`${varName}_max = ${rangeParsedValue.max}`);
                globalEffectVariableMapping[effect.id] = varName;
              }
              return;
            }

            const varName = getUniqueVariableName("levels");
            configItems.push(`${varName} = ${value}`);
            globalEffectVariableMapping[effect.id] = varName;
          }

          if (
            effect.type === "apply_x_chips" &&
            typeof effectValue === "number" &&
            !allVariableNames.has(String(effectValue))
          ) {
            const varName = getUniqueVariableName("xchips");
            configItems.push(`${varName} = ${effectValue}`);
            globalEffectVariableMapping[effect.id] = varName;
          }

          if (
            effect.type === "apply_exp_mult" &&
            typeof effectValue === "number" &&
            !allVariableNames.has(String(effectValue))
          ) {
            const varName = getUniqueVariableName("emult");
            configItems.push(`${varName} = ${effectValue}`);
            globalEffectVariableMapping[effect.id] = varName;
          }

          if (
            effect.type === "apply_exp_chips" &&
            typeof effectValue === "number" &&
            !allVariableNames.has(String(effectValue))
          ) {
            const varName = getUniqueVariableName("echips");
            configItems.push(`${varName} = ${effectValue}`);
            globalEffectVariableMapping[effect.id] = varName;
          }

          if (
            effect.type === "set_dollars" &&
            typeof effectValue === "number" &&
            !allVariableNames.has(String(effectValue))
          ) {
            const varName = getUniqueVariableName("set_dollars");
            configItems.push(`${varName} = ${effectValue}`);
            globalEffectVariableMapping[effect.id] = varName;
          }

          if (effect.type === "add_sell_value") {
            const effectValue = effect.params.value;
            const parsed = parseGameVariable(effectValue);
            const rangeParsed = parseRangeVariable(effectValue);

            if (parsed.isGameVariable || rangeParsed.isRangeVariable) {
              if (rangeParsed.isRangeVariable) {
                const varName = getUniqueVariableName("sell_value");
                configItems.push(`${varName}_min = ${rangeParsed.min}`);
                configItems.push(`${varName}_max = ${rangeParsed.max}`);
                globalEffectVariableMapping[effect.id] = varName;
              }
              return;
            }

            if (
              typeof effectValue === "number" &&
              !allVariableNames.has(String(effectValue))
            ) {
              const varName = getUniqueVariableName("sell_value");
              configItems.push(`${varName} = ${effectValue}`);
              globalEffectVariableMapping[effect.id] = varName;
            }
          }
          if (effect.type === "set_ante") {
            const value = effect.params.value;
            const parsedValue = parseGameVariable(value);
            const rangeParsedValue = parseRangeVariable(value);

            if (
              parsedValue.isGameVariable ||
              rangeParsedValue.isRangeVariable
            ) {
              if (rangeParsedValue.isRangeVariable) {
                const varName = getUniqueVariableName("ante_value");
                configItems.push(`${varName}_min = ${rangeParsedValue.min}`);
                configItems.push(`${varName}_max = ${rangeParsedValue.max}`);
                globalEffectVariableMapping[effect.id] = varName;
              }
              return;
            }

            if (
              typeof value === "number" &&
              !allVariableNames.has(String(value))
            ) {
              const varName = getUniqueVariableName("ante_value");
              configItems.push(`${varName} = ${value}`);
              globalEffectVariableMapping[effect.id] = varName;
            }
          }
        });
      });
    });
  }

  return configItems.join(",\n            ");
};

const generateCalculateFunction = (rules: Rule[], joker: JokerData): string => {
  const rulesByTrigger: Record<string, Rule[]> = {};
  rules.forEach((rule) => {
    if (!rulesByTrigger[rule.trigger]) {
      rulesByTrigger[rule.trigger] = [];
    }
    rulesByTrigger[rule.trigger].push(rule);
  });

  let calculateFunction = `calculate = function(self, card, context)`;

  Object.entries(rulesByTrigger).forEach(([triggerType, triggerRules]) => {
    const sortedRules = [...triggerRules].sort((a, b) => {
      const aHasConditions = generateConditionChain(a, joker).length > 0;
      const bHasConditions = generateConditionChain(b, joker).length > 0;

      if (aHasConditions && !bHasConditions) return -1;
      if (!aHasConditions && bHasConditions) return 1;
      return 0;
    });

    const hasRetriggerEffects = sortedRules.some((rule) =>
      [
        ...(rule.effects || []),
        ...(rule.randomGroups?.flatMap((g) => g.effects) || []),
      ].some((effect) => effect.type === "retrigger_cards")
    );

    const hasDeleteEffects =
      triggerType !== "card_discarded" &&
      sortedRules.some((rule) =>
        [
          ...(rule.effects || []),
          ...(rule.randomGroups?.flatMap((g) => g.effects) || []),
        ].some((effect) => effect.type === "delete_triggered_card")
      );

    if (hasDeleteEffects) {
      calculateFunction += `
        if context.destroy_card and context.destroy_card.should_destroy and not context.blueprint then
            return { remove = true }
        end`;
    }

    if (hasRetriggerEffects) {
      const retriggerContextCheck =
        triggerType === "card_held_in_hand" ||
        triggerType === "card_held_in_hand_end_of_round"
          ? "context.repetition and context.cardarea == G.hand and (next(context.card_effects[1]) or #context.card_effects > 1)"
          : "context.repetition and context.cardarea == G.play";

      calculateFunction += `
        if ${retriggerContextCheck} then`;

      let hasAnyConditions = false;

      sortedRules.forEach((rule) => {
        const regularRetriggerEffects = (rule.effects || []).filter(
          (e) => e.type === "retrigger_cards"
        );
        const randomRetriggerEffects = (rule.randomGroups || []).filter(
          (group) => group.effects.some((e) => e.type === "retrigger_cards")
        );

        if (
          regularRetriggerEffects.length === 0 &&
          randomRetriggerEffects.length === 0
        )
          return;

        const conditionCode = generateConditionChain(rule, joker);

        if (conditionCode) {
          const conditional = hasAnyConditions ? "elseif" : "if";
          calculateFunction += `
            ${conditional} ${conditionCode} then`;
          hasAnyConditions = true;
        } else {
          if (hasAnyConditions) {
            calculateFunction += `
            else`;
          }
        }

        const { statement, preReturnCode } = generateEffectReturnStatement(
          regularRetriggerEffects,
          convertRandomGroupsForCodegen(randomRetriggerEffects),
          triggerType,
          rule.id
        );

        if (preReturnCode) {
          calculateFunction += `
                ${preReturnCode}`;
        }

        if (statement) {
          calculateFunction += `
                ${statement}`;
        }
      });

      if (hasAnyConditions) {
        calculateFunction += `
            end`;
      }

      calculateFunction += `
        end`;

      const hasNonRetriggerEffects = sortedRules.some((rule) => {
        const regularNonRetriggerEffects = (rule.effects || []).filter(
          (e) => e.type !== "retrigger_cards"
        );
        const randomNonRetriggerGroups = (rule.randomGroups || [])
          .map((group) => ({
            ...group,
            effects: group.effects.filter((e) => e.type !== "retrigger_cards"),
          }))
          .filter((group) => group.effects.length > 0);

        return (
          regularNonRetriggerEffects.length > 0 ||
          randomNonRetriggerGroups.length > 0
        );
      });

      if (hasNonRetriggerEffects) {
        const nonRetriggerContextCheck =
          triggerType === "card_held_in_hand" ||
          triggerType === "card_held_in_hand_end_of_round"
            ? "context.individual and context.cardarea == G.hand and not context.end_of_round and not context.blueprint"
            : triggerType === "card_discarded"
            ? "context.discard and not context.blueprint"
            : "context.individual and context.cardarea == G.play and not context.blueprint";

        calculateFunction += `
        if ${nonRetriggerContextCheck} then`;

        if (hasDeleteEffects) {
          calculateFunction += `
            context.other_card.should_destroy = false`;
        }

        hasAnyConditions = false;

        sortedRules.forEach((rule) => {
          const regularNonRetriggerEffects = (rule.effects || []).filter(
            (e) => e.type !== "retrigger_cards"
          );
          const randomNonRetriggerGroups = (rule.randomGroups || [])
            .map((group) => ({
              ...group,
              effects: group.effects.filter(
                (e) => e.type !== "retrigger_cards"
              ),
            }))
            .filter((group) => group.effects.length > 0);

          if (
            regularNonRetriggerEffects.length === 0 &&
            randomNonRetriggerGroups.length === 0
          )
            return;

          const conditionCode = generateConditionChain(rule, joker);

          if (conditionCode) {
            const conditional = hasAnyConditions ? "elseif" : "if";
            calculateFunction += `
            ${conditional} ${conditionCode} then`;
            hasAnyConditions = true;
          } else {
            if (hasAnyConditions) {
              calculateFunction += `
            else`;
            }
          }

          const hasDeleteInThisRule = [
            ...(rule.effects || []),
            ...(rule.randomGroups?.flatMap((g) => g.effects) || []),
          ].some((effect) => effect.type === "delete_triggered_card");

          if (hasDeleteInThisRule) {
            calculateFunction += `
                context.other_card.should_destroy = true`;
          }

          const { statement, preReturnCode } = generateEffectReturnStatement(
            regularNonRetriggerEffects,
            convertRandomGroupsForCodegen(randomNonRetriggerGroups),
            triggerType,
            rule.id
          );

          if (preReturnCode) {
            calculateFunction += `
                ${preReturnCode}`;
          }

          if (statement) {
            calculateFunction += `
                ${statement}`;
          }
        });

        if (hasAnyConditions) {
          calculateFunction += `
            end`;
        }

        calculateFunction += `
        end`;
      }
    } else if (hasDeleteEffects) {
      const individualContextCheck =
        triggerType === "card_held_in_hand" ||
        triggerType === "card_held_in_hand_end_of_round"
          ? "context.individual and context.cardarea == G.hand and not context.end_of_round and not context.blueprint"
          : triggerType === "card_discarded"
          ? "context.discard and not context.blueprint"
          : "context.individual and context.cardarea == G.play and not context.blueprint";

      calculateFunction += `
        if ${individualContextCheck} then
            context.other_card.should_destroy = false`;

      let hasAnyConditions = false;

      sortedRules.forEach((rule) => {
        const regularDeleteEffects = (rule.effects || []).filter(
          (e) => e.type === "delete_triggered_card"
        );
        const randomDeleteGroups = (rule.randomGroups || []).filter((group) =>
          group.effects.some((e) => e.type === "delete_triggered_card")
        );

        const regularNonDeleteEffects = (rule.effects || []).filter(
          (e) => e.type !== "delete_triggered_card"
        );
        const randomNonDeleteGroups = (rule.randomGroups || [])
          .map((group) => ({
            ...group,
            effects: group.effects.filter(
              (e) => e.type !== "delete_triggered_card"
            ),
          }))
          .filter((group) => group.effects.length > 0);

        if (
          regularDeleteEffects.length === 0 &&
          randomDeleteGroups.length === 0 &&
          regularNonDeleteEffects.length === 0 &&
          randomNonDeleteGroups.length === 0
        )
          return;

        const conditionCode = generateConditionChain(rule, joker);

        if (conditionCode) {
          const conditional = hasAnyConditions ? "elseif" : "if";
          calculateFunction += `
            ${conditional} ${conditionCode} then`;
          hasAnyConditions = true;
        } else {
          if (hasAnyConditions) {
            calculateFunction += `
            else`;
          }
        }

        if (regularDeleteEffects.length > 0 || randomDeleteGroups.length > 0) {
          calculateFunction += `
                context.other_card.should_destroy = true`;
        }

        const allEffects = [
          ...regularNonDeleteEffects,
          ...regularDeleteEffects,
        ];
        const allGroups = [...randomNonDeleteGroups, ...randomDeleteGroups];

        if (allEffects.length > 0 || allGroups.length > 0) {
          const { statement, preReturnCode } = generateEffectReturnStatement(
            allEffects,
            convertRandomGroupsForCodegen(allGroups),
            triggerType,
            rule.id
          );

          if (preReturnCode) {
            calculateFunction += `
                ${preReturnCode}`;
          }

          if (statement) {
            calculateFunction += `
                ${statement}`;
          }
        }
      });

      if (hasAnyConditions) {
        calculateFunction += `
            end`;
      }

      calculateFunction += `
        end`;
    } else {
      const triggerContext = generateTriggerContext(triggerType, sortedRules);

      calculateFunction += `
        if ${triggerContext.check} then`;

      let hasAnyConditions = false;

      sortedRules.forEach((rule) => {
        const conditionCode = generateConditionChain(rule, joker);

        if (conditionCode) {
          const conditional = hasAnyConditions ? "elseif" : "if";
          calculateFunction += `
            ${conditional} ${conditionCode} then`;
          hasAnyConditions = true;
        } else {
          if (hasAnyConditions) {
            calculateFunction += `
            else`;
          }
        }

        const { statement, preReturnCode } = generateEffectReturnStatement(
          rule.effects || [],
          convertRandomGroupsForCodegen(rule.randomGroups || []),
          triggerType,
          rule.id
        );

        if (preReturnCode) {
          calculateFunction += `
                ${preReturnCode}`;
        }

        if (statement) {
          calculateFunction += `
                ${statement}`;
        }
      });

      if (hasAnyConditions) {
        calculateFunction += `
            end`;
      }

      calculateFunction += `
        end`;
    }
  });

  calculateFunction += `
    end`;

  return calculateFunction;
};

const generateLocVarsFunction = (
  joker: JokerData,
  passiveEffects: PassiveEffectResult[]
): string => {
  const descriptionHasVariables = joker.description.includes("#");
  if (!descriptionHasVariables) {
    return `loc_vars = function(self, info_queue, card)
        return {vars = {}}
    end`;
  }

  const variablePlaceholders = joker.description.match(/#(\d+)#/g) || [];
  const maxVariableIndex = Math.max(
    ...variablePlaceholders.map((placeholder) =>
      parseInt(placeholder.replace(/#/g, ""))
    ),
    0
  );

  if (maxVariableIndex === 0) {
    return `loc_vars = function(self, info_queue, card)
        return {vars = {}}
    end`;
  }

  const allVariables = getAllVariables(joker);
  const gameVariables = extractGameVariablesFromRules(joker.rules || []);
  const suitVariables = (joker.userVariables || []).filter(
    (v) => v.type === "suit"
  );
  const rankVariables = (joker.userVariables || []).filter(
    (v) => v.type === "rank"
  );
  const pokerHandVariables = (joker.userVariables || []).filter(
    (v) => v.type === "pokerhand"
  );

  const hasRandomGroups =
    joker.rules?.some(
      (rule) => rule.randomGroups && rule.randomGroups.length > 0
    ) || false;

  const variableMapping: string[] = [];
  const colorVariables: string[] = [];

  if (hasRandomGroups) {
    const nonPassiveRules =
      joker.rules?.filter((rule) => rule.trigger !== "passive") || [];
    const randomGroups = nonPassiveRules.flatMap(
      (rule) => rule.randomGroups || []
    );
    const denominators = [
      ...new Set(randomGroups.map((group) => group.chance_denominator)),
    ];

    variableMapping.push("G.GAME.probabilities.normal");

    if (denominators.length === 1) {
      variableMapping.push("card.ability.extra.odds");
    } else {
      denominators.forEach((_, index) => {
        if (index === 0) {
          variableMapping.push("card.ability.extra.odds");
        } else {
          variableMapping.push(`card.ability.extra.odds${index + 1}`);
        }
      });
    }

    const remainingVars = allVariables.filter(
      (v) =>
        v.name !== "numerator" &&
        v.name !== "denominator" &&
        !v.name.startsWith("numerator") &&
        !v.name.startsWith("denominator") &&
        v.type !== "suit" &&
        v.type !== "rank" &&
        v.type !== "pokerhand"
    );
    const remainingGameVars = gameVariables.filter(
      (gv) =>
        !gv.name.toLowerCase().includes("numerator") &&
        !gv.name.toLowerCase().includes("denominator")
    );

    let currentIndex = denominators.length + 1;

    for (const variable of remainingVars) {
      if (currentIndex >= maxVariableIndex) break;
      variableMapping.push(`card.ability.extra.${variable.name}`);
      currentIndex++;
    }

    for (const gameVar of remainingGameVars) {
      if (currentIndex >= maxVariableIndex) break;
      const varName = gameVar.name.replace(/\s+/g, "").toLowerCase();
      if (gameVar.multiplier === 1 && gameVar.startsFrom === 0) {
        variableMapping.push(gameVar.code);
      } else if (gameVar.startsFrom === 0) {
        variableMapping.push(`(${gameVar.code}) * ${gameVar.multiplier}`);
      } else if (gameVar.multiplier === 1) {
        variableMapping.push(
          `card.ability.extra.${varName} + (${gameVar.code})`
        );
      } else {
        variableMapping.push(
          `card.ability.extra.${varName} + (${gameVar.code}) * ${gameVar.multiplier}`
        );
      }
      currentIndex++;
    }

    for (const suitVar of suitVariables) {
      if (currentIndex >= maxVariableIndex) break;
      variableMapping.push(
        `localize((G.GAME.current_round.${suitVar.name}_card or {}).suit or 'Spades', 'suits_singular')`
      );
      colorVariables.push(
        `G.C.SUITS[(G.GAME.current_round.${suitVar.name}_card or {}).suit or 'Spades']`
      );
      currentIndex++;
    }

    for (const rankVar of rankVariables) {
      if (currentIndex >= maxVariableIndex) break;
      variableMapping.push(
        `localize((G.GAME.current_round.${rankVar.name}_card or {}).rank or 'A', 'ranks')`
      );
      currentIndex++;
    }

    for (const pokerHandVar of pokerHandVariables) {
      if (currentIndex >= maxVariableIndex) break;
      variableMapping.push(
        `localize((G.GAME.current_round.${pokerHandVar.name}_hand or 'High Card'), 'poker_hands')`
      );
      currentIndex++;
    }
  } else {
    let currentIndex = 0;

    for (const variable of allVariables) {
      if (currentIndex >= maxVariableIndex) break;

      if (
        !variable.id.startsWith("auto_gamevar_") &&
        variable.type !== "suit" &&
        variable.type !== "rank" &&
        variable.type !== "pokerhand"
      ) {
        variableMapping.push(`card.ability.extra.${variable.name}`);
        currentIndex++;
      }
    }

    for (const suitVar of suitVariables) {
      if (currentIndex >= maxVariableIndex) break;
      variableMapping.push(
        `localize((G.GAME.current_round.${suitVar.name}_card or {}).suit or 'Spades', 'suits_singular')`
      );
      colorVariables.push(
        `G.C.SUITS[(G.GAME.current_round.${suitVar.name}_card or {}).suit or 'Spades']`
      );
      currentIndex++;
    }

    for (const rankVar of rankVariables) {
      if (currentIndex >= maxVariableIndex) break;
      variableMapping.push(
        `localize((G.GAME.current_round.${rankVar.name}_card or {}).rank or 'Ace', 'ranks')`
      );
      currentIndex++;
    }

    for (const pokerHandVar of pokerHandVariables) {
      if (currentIndex >= maxVariableIndex) break;
      variableMapping.push(
        `localize((G.GAME.current_round.${pokerHandVar.name}_hand or 'High Card'), 'poker_hands')`
      );
      currentIndex++;
    }

    for (const gameVar of gameVariables) {
      if (currentIndex >= maxVariableIndex) break;
      const varName = gameVar.name.replace(/\s+/g, "").toLowerCase();
      if (gameVar.multiplier === 1 && gameVar.startsFrom === 0) {
        variableMapping.push(gameVar.code);
      } else if (gameVar.startsFrom === 0) {
        variableMapping.push(`(${gameVar.code}) * ${gameVar.multiplier}`);
      } else if (gameVar.multiplier === 1) {
        variableMapping.push(
          `card.ability.extra.${varName} + (${gameVar.code})`
        );
      } else {
        variableMapping.push(
          `card.ability.extra.${varName} + (${gameVar.code}) * ${gameVar.multiplier}`
        );
      }
      currentIndex++;
    }
  }

  passiveEffects.forEach((effect) => {
    if (effect.locVars) {
      effect.locVars.forEach((locVar) => {
        if (
          !variableMapping.includes(locVar) &&
          variableMapping.length < maxVariableIndex
        ) {
          variableMapping.push(locVar);
        }
      });
    }
  });

  const finalVars = variableMapping.slice(0, maxVariableIndex);

  let locVarsReturn = `{vars = {${finalVars.join(", ")}}}`;

  if (colorVariables.length > 0) {
    locVarsReturn = `{vars = {${finalVars.join(
      ", "
    )}}, colours = {${colorVariables.join(", ")}}}`;
  }

  return `loc_vars = function(self, info_queue, card)
        return ${locVarsReturn}
    end`;
};

export const slugify = (text: string): string => {
  return (
    text
      .toLowerCase()
      .replace(/[\s\W_]+/g, "")
      .replace(/^[\d]/, "_$&") ||
    `joker_${Math.random().toString(36).substring(2, 8)}`
  );
};

const formatJokerDescription = (joker: JokerData): string => {
  // First convert any HTML breaks to [s] tags
  const formatted = joker.description.replace(/<br\s*\/?>/gi, "[s]");

  // Split only on [s] tags, removing the [s] markers
  const lines = formatted
    .split("[s]")
    .map((line) => line.trim())
    .filter((line) => line.length > 0);

  // If no [s] tags were found, treat the entire description as one line
  if (lines.length === 0) {
    lines.push(formatted.trim());
  }

  return `{\n${lines
    .map((line, i) => `            [${i + 1}] = '${line.replace(/'/g, "\\'")}'`)
    .join(",\n")}\n        }`;
};

export const getEffectVariableName = (
  effectId: string,
  fallback: string
): string => {
  return globalEffectVariableMapping[effectId] || fallback;
};

const generateHooks = (jokers: JokerData[], modPrefix: string): string => {
  // Don't generate hooks if there's no mod prefix (single joker case, this might need to be changed or something)
  if (!modPrefix) return "";

  let allHooks = "";

  // Collect all jokers that need hooks by type
  const hooksByType: Record<
    string,
    Array<{ jokerKey: string; params: unknown }>
  > = {};

  jokers.forEach((joker) => {
    const passiveEffects = processPassiveEffects(joker);
    const jokerKey = slugify(joker.name);

    passiveEffects.forEach((effect) => {
      if (effect.needsHook) {
        const hookType = effect.needsHook.hookType;
        if (!hooksByType[hookType]) {
          hooksByType[hookType] = [];
        }
        hooksByType[hookType].push({
          jokerKey,
          params: effect.needsHook.effectParams,
        });
      }
    });
  });

  if (hooksByType.discount_items) {
    allHooks += generateDiscountItemsHook(
      hooksByType.discount_items as Array<{
        jokerKey: string;
        params: {
          discountType: string;
          discountMethod: string;
          discountAmount: number;
        };
      }>,
      modPrefix
    );
  }

  if (hooksByType.reduce_flush_straight_requirements) {
    allHooks += generateReduceFlushStraightRequirementsHook(
      hooksByType.reduce_flush_straight_requirements as Array<{
        jokerKey: string;
        params: {
          reductionValue: number;
        };
      }>,
      modPrefix
    );
  }

  if (hooksByType.shortcut) {
    allHooks += generateShortcutHook(
      hooksByType.shortcut as Array<{
        jokerKey: string;
        params: Record<string, unknown>;
      }>,
      modPrefix
    );
  }

  // if (hooksByType.other_effect) {
  //   allHooks += generateOtherEffectHook(
  //     hooksByType.other_effect as Array<{
  //       jokerKey: string;
  //       params: { otherParam1: string; otherParam2: number }
  //     }>,
  //     modPrefix
  //   );
  // }
  // blah blah blah

  return allHooks;
};

const generateModJson = (metadata: ModMetadata): string => {
  const modJson: Record<string, unknown> = {
    id: metadata.id,
    name: metadata.name,
    author: metadata.author,
    description: metadata.description,
    prefix: metadata.prefix,
    main_file: metadata.main_file,
    version: metadata.version,
    priority: metadata.priority,
    badge_colour: metadata.badge_colour,
    badge_text_colour: metadata.badge_text_colour,
  };

  if (metadata.display_name && metadata.display_name !== metadata.name) {
    modJson.display_name = metadata.display_name;
  }

  if (metadata.dependencies && metadata.dependencies.length > 0) {
    modJson.dependencies = metadata.dependencies;
  }

  if (metadata.conflicts && metadata.conflicts.length > 0) {
    modJson.conflicts = metadata.conflicts;
  }

  if (metadata.provides && metadata.provides.length > 0) {
    modJson.provides = metadata.provides;
  }

  if (metadata.dump_loc) {
    modJson.dump_loc = metadata.dump_loc;
  }

  return JSON.stringify(modJson, null, 2);
};
