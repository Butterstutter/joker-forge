import { JokerData } from "../JokerCard";
import JSZip from "jszip";
import { addAtlasToZip } from "./ImageProcessor";
import { generateTriggerContext } from "./triggerUtils";
import { generateConditionChain } from "./conditionUtils";
import {
  generateEffectReturnStatement,
  processPassiveEffects,
} from "./effectUtils";
import {
  extractVariablesFromRules,
  generateVariableConfig,
  generateVariableLocVars,
} from "./variableUtils";
import type { Rule } from "../ruleBuilder/types";
import type { PassiveEffectResult } from "./effectUtils";

export interface ModMetadata {
  id: string;
  name: string;
  author: string[];
  description: string;
  prefix: string;
  main_file: string;
  version: string;
  priority: number;
  badge_colour: string;
  badge_text_colour: string;
  display_name: string;
  dependencies: string[];
  conflicts: string[];
  provides: string[];
  dump_loc?: boolean;
}

interface EffectVariableMapping {
  [effectId: string]: string;
}

let globalEffectVariableMapping: EffectVariableMapping = {};

export const exportJokersAsMod = async (
  jokers: JokerData[],
  metadata: ModMetadata
): Promise<boolean> => {
  try {
    const zip = new JSZip();

    zip.file(metadata.main_file, generateMainLua(jokers, metadata));
    zip.file(`${metadata.id}.json`, generateModJson(metadata));
    zip.file("config.lua", "return {}");

    await addAtlasToZip(zip, jokers);

    console.log(jokers);

    const content = await zip.generateAsync({ type: "blob" });
    const url = URL.createObjectURL(content);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${metadata.id}.zip`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    return true;
  } catch (error) {
    console.error("Failed to generate mod:", error);
    return false;
  }
};

const generateMainLua = (
  jokers: JokerData[],
  metadata: ModMetadata
): string => {
  let output = `-- FILE GENERATED BY JOKER FORGE
-- Mod: ${metadata.name}
-- Author(s): ${metadata.author.join(", ")}
-- Version: ${metadata.version}
-- Description: ${metadata.description}

local mod = SMODS.current_mod

mod.config = {}

-- Atlas
SMODS.Atlas({
    key = "CustomJokers", 
    path = "CustomJokers.png", 
    px = 71,
    py = 95, 
    atlas_table = "ASSET_ATLAS"
}):register()

`;

  jokers.forEach((joker, index) => {
    output += generateJokerCode(joker, index, "CustomJokers", jokers) + "\n\n";
  });

  output += "return mod";
  return output;
};

const generateJokerCode = (
  joker: JokerData,
  index: number,
  atlasKey: string,
  allJokers: JokerData[]
): string => {
  const passiveEffects = processPassiveEffects(joker);

  let jokerCode = generateJokerBase(
    joker,
    index,
    atlasKey,
    passiveEffects,
    allJokers
  );

  const locVarsCode = generateLocVarsFunction(joker, passiveEffects);
  jokerCode += `,\n\n    ${locVarsCode}`;

  const nonPassiveRules =
    joker.rules?.filter((rule) => rule.trigger !== "passive") || [];

  if (nonPassiveRules.length > 0) {
    const calculateCode = generateCalculateFunction(nonPassiveRules);
    jokerCode += `,\n\n    ${calculateCode}`;
  }

  passiveEffects.forEach((effect) => {
    if (effect.addToDeck) {
      jokerCode += `,\n\n    add_to_deck = function(self, card, from_debuff)
        ${effect.addToDeck}
    end`;
    }

    if (effect.removeFromDeck) {
      jokerCode += `,\n\n    remove_from_deck = function(self, card, from_debuff)
        ${effect.removeFromDeck}
    end`;
    }

    if (effect.calculateFunction) {
      jokerCode += `,\n\n    ${effect.calculateFunction}`;
    }
  });

  jokerCode += `\n}`;
  return jokerCode;
};

const generateJokerBase = (
  joker: JokerData,
  index: number,
  atlasKey: string,
  passiveEffects: PassiveEffectResult[],
  allJokers: JokerData[]
): string => {
  let totalSlotsUsed = 0;
  for (let i = 0; i < index; i++) {
    totalSlotsUsed += allJokers[i].overlayImagePreview ? 2 : 1;
  }

  const x = totalSlotsUsed % 10;
  const y = Math.floor(totalSlotsUsed / 10);

  globalEffectVariableMapping = {};
  const effectsConfig = extractEffectsConfig(joker, passiveEffects);

  let jokerCode = `SMODS.Joker{ --${joker.name}
    name = "${joker.name}",
    key = "${slugify(joker.name)}",
    config = {
        extra = {`;

  if (effectsConfig.trim()) {
    jokerCode += `
            ${effectsConfig}`;
  }

  jokerCode += `
        }
    },
    loc_txt = {
        ['name'] = '${joker.name}',
        ['text'] = ${formatJokerDescription(joker)}
    },
    pos = {
        x = ${x},
        y = ${y}
    },
    cost = ${joker.cost !== undefined ? joker.cost : 4},
    rarity = ${joker.rarity},
    blueprint_compat = ${
      joker.blueprint_compat !== undefined ? joker.blueprint_compat : true
    },
    eternal_compat = ${
      joker.eternal_compat !== undefined ? joker.eternal_compat : true
    },
    unlocked = ${joker.unlocked !== undefined ? joker.unlocked : true},
    discovered = ${joker.discovered !== undefined ? joker.discovered : true},
    atlas = '${atlasKey}'`;

  if (joker.overlayImagePreview) {
    const soulX = (totalSlotsUsed + 1) % 10;
    const soulY = Math.floor((totalSlotsUsed + 1) / 10);
    jokerCode += `,
    soul_pos = {
        x = ${soulX},
        y = ${soulY}
    }`;
  }

  return jokerCode;
};

const extractEffectsConfig = (
  joker: JokerData,
  passiveEffects: PassiveEffectResult[]
): string => {
  const configItems: string[] = [];
  const variableCountByType: Record<string, number> = {};

  const getUniqueVariableName = (baseName: string): string => {
    if (variableCountByType[baseName] === undefined) {
      variableCountByType[baseName] = 0;
      return baseName;
    } else {
      variableCountByType[baseName]++;
      return `${baseName}${variableCountByType[baseName]}`;
    }
  };

  const allVariableNames = new Set<string>();
  if (joker.userVariables) {
    joker.userVariables.forEach((v) => allVariableNames.add(v.name));
  }

  passiveEffects.forEach((effect) => {
    if (effect.configVariables) {
      effect.configVariables.forEach((configVar) => {
        if (configVar.trim()) {
          configItems.push(configVar);
        }
      });
    }
  });

  if (joker.userVariables && joker.userVariables.length > 0) {
    joker.userVariables.forEach((variable) => {
      configItems.push(`${variable.name} = ${variable.initialValue}`);
    });
  }

  if (joker.rules && joker.rules.length > 0) {
    const nonPassiveRules = joker.rules.filter(
      (rule) => rule.trigger !== "passive"
    );
    const variables = extractVariablesFromRules(nonPassiveRules);

    const userVariableNames = new Set(
      joker.userVariables?.map((v) => v.name) || []
    );
    const autoVariables = variables.filter(
      (v) => !userVariableNames.has(v.name)
    );

    if (autoVariables.length > 0) {
      const variableConfig = generateVariableConfig(autoVariables);
      if (variableConfig) {
        configItems.push(variableConfig);
      }
    }

    // Check for random chance effects and add odds to config
    let hasAddedOdds = false;
    nonPassiveRules.forEach((rule) => {
      rule.effects.forEach((effect) => {
        // Add odds for random chance effects
        if (effect.params.has_random_chance === "true" && !hasAddedOdds) {
          const denominator = effect.params.chance_denominator || 4;
          configItems.push(`odds = ${denominator}`);
          hasAddedOdds = true;
        }

        const effectValue = effect.params.value;

        if (
          effect.type === "add_chips" &&
          typeof effectValue === "number" &&
          !allVariableNames.has(String(effectValue))
        ) {
          const varName = getUniqueVariableName("chips");
          configItems.push(`${varName} = ${effectValue}`);
          globalEffectVariableMapping[effect.id] = varName;
        }

        if (
          effect.type === "add_mult" &&
          typeof effectValue === "number" &&
          !allVariableNames.has(String(effectValue))
        ) {
          const varName = getUniqueVariableName("mult");
          configItems.push(`${varName} = ${effectValue}`);
          globalEffectVariableMapping[effect.id] = varName;
        }

        if (
          effect.type === "apply_x_mult" &&
          typeof effectValue === "number" &&
          !allVariableNames.has(String(effectValue))
        ) {
          const varName = getUniqueVariableName("Xmult");
          configItems.push(`${varName} = ${effectValue}`);
          globalEffectVariableMapping[effect.id] = varName;
        }

        if (
          effect.type === "add_dollars" &&
          typeof effectValue === "number" &&
          !allVariableNames.has(String(effectValue))
        ) {
          const varName = getUniqueVariableName("dollars");
          configItems.push(`${varName} = ${effectValue}`);
          globalEffectVariableMapping[effect.id] = varName;
        }

        if (effect.type === "retrigger_cards") {
          const repetitions = effect.params.repetitions || 1;
          const varName = getUniqueVariableName("repetitions");
          configItems.push(`${varName} = ${repetitions}`);
          globalEffectVariableMapping[effect.id] = varName;
        }

        if (effect.type === "edit_hand") {
          const value = effect.params.value || 1;
          const varName = getUniqueVariableName("hands");
          configItems.push(`${varName} = ${value}`);
          globalEffectVariableMapping[effect.id] = varName;
        }

        if (effect.type === "edit_discard") {
          const value = effect.params.value || 1;
          const varName = getUniqueVariableName("discards");
          configItems.push(`${varName} = ${value}`);
          globalEffectVariableMapping[effect.id] = varName;
        }

        if (effect.type === "level_up_hand") {
          const value = effect.params.value || 1;
          const varName = getUniqueVariableName("levels");
          configItems.push(`${varName} = ${value}`);
          globalEffectVariableMapping[effect.id] = varName;
        }
      });
    });
  }

  return configItems.join(",\n            ");
};

const generateCalculateFunction = (rules: Rule[]): string => {
  const rulesByTrigger: Record<string, Rule[]> = {};
  rules.forEach((rule) => {
    if (!rulesByTrigger[rule.trigger]) {
      rulesByTrigger[rule.trigger] = [];
    }
    rulesByTrigger[rule.trigger].push(rule);
  });

  let calculateFunction = `calculate = function(self, card, context)`;

  Object.entries(rulesByTrigger).forEach(([triggerType, triggerRules]) => {
    const triggerContext = generateTriggerContext(triggerType, triggerRules);

    calculateFunction += `
        ${triggerContext.comment}
        if ${triggerContext.check} then`;

    let hasAnyConditions = false;

    triggerRules.forEach((rule) => {
      const conditionCode = generateConditionChain(rule);

      if (conditionCode) {
        const conditional = hasAnyConditions ? "elseif" : "if";
        calculateFunction += `
            ${conditional} ${conditionCode} then`;
        hasAnyConditions = true;
      } else {
        if (hasAnyConditions) {
          calculateFunction += `
            else`;
        }
      }

      const { statement, preReturnCode } = generateEffectReturnStatement(
        rule.effects,
        triggerType,
        rule.id
      );

      if (preReturnCode) {
        calculateFunction += `
                ${preReturnCode}`;
      }

      if (statement) {
        calculateFunction += `
                ${statement}`;
      }
    });

    if (hasAnyConditions) {
      calculateFunction += `
            end`;
    }

    calculateFunction += `
        end`;
  });

  calculateFunction += `
    end`;

  return calculateFunction;
};

const generateLocVarsFunction = (
  joker: JokerData,
  passiveEffects: PassiveEffectResult[]
): string => {
  const vars: string[] = [];
  const processedVarNames = new Set<string>();

  // Check if the joker description actually contains variable placeholders
  const descriptionHasVariables = joker.description.includes("#");

  // Only add random chance variables if the description uses them
  let hasRandomChance = false;
  if (joker.rules && descriptionHasVariables) {
    joker.rules.forEach((rule) => {
      rule.effects.forEach((effect) => {
        if (effect.params.has_random_chance === "true") {
          hasRandomChance = true;
        }
      });
    });
  }

  // Only add probability variables if description contains #1# and #2# for random chance
  if (
    hasRandomChance &&
    joker.description.includes("#1#") &&
    joker.description.includes("#2#")
  ) {
    vars.push("G.GAME.probabilities.normal");
    vars.push("card.ability.extra.odds");
    processedVarNames.add("odds");
  }

  passiveEffects.forEach((effect) => {
    if (effect.locVars) {
      effect.locVars.forEach((locVar) => {
        if (locVar.trim()) {
          vars.push(locVar);
        }
      });
    }
  });

  if (joker.userVariables && joker.userVariables.length > 0) {
    joker.userVariables.forEach((variable) => {
      if (!processedVarNames.has(variable.name)) {
        vars.push(`card.ability.extra.${variable.name}`);
        processedVarNames.add(variable.name);
      }
    });
  }

  if (joker.rules && joker.rules.length > 0 && descriptionHasVariables) {
    const nonPassiveRules = joker.rules.filter(
      (rule) => rule.trigger !== "passive"
    );

    const variables = extractVariablesFromRules(nonPassiveRules);
    const variableLocVars = generateVariableLocVars(variables);

    variableLocVars.forEach((locVar) => {
      const varName = locVar.split(".").pop() || "";
      if (!processedVarNames.has(varName)) {
        vars.push(locVar);
        processedVarNames.add(varName);
      }
    });

    nonPassiveRules.forEach((rule) => {
      rule.effects.forEach((effect) => {
        const configVarName = globalEffectVariableMapping[effect.id];
        if (configVarName && !processedVarNames.has(configVarName)) {
          // Only add if the description actually uses variables
          const effectValue = effect.params.value;
          if (typeof effectValue === "number" && descriptionHasVariables) {
            vars.push(`card.ability.extra.${configVarName}`);
            processedVarNames.add(configVarName);
          }
        }
      });
    });
  }

  return `loc_vars = function(self, info_queue, card)
        return {vars = {${vars.join(", ")}}}
    end`;
};

const slugify = (text: string): string => {
  return (
    text
      .toLowerCase()
      .replace(/[\s\W_]+/g, "")
      .replace(/^[\d]/, "_$&") ||
    `joker_${Math.random().toString(36).substring(2, 8)}`
  );
};

const formatJokerDescription = (joker: JokerData): string => {
  const formatted = joker.description.replace(/<br\s*\/?>/gi, "[s]");

  const words = formatted.split(" ");
  const lines = [];
  let line = "";

  words.forEach((word) => {
    if (line.length + word.length + 1 > 28 || word.includes("[s]")) {
      lines.push(line.trim());
      line = "";
    }
    line += (line ? " " : "") + word.replace("[s]", "");
  });

  if (line) lines.push(line.trim());

  return `{\n${lines
    .map((line, i) => `            [${i + 1}] = '${line.replace(/'/g, "\\'")}'`)
    .join(",\n")}\n        }`;
};

export const getEffectVariableName = (
  effectId: string,
  fallback: string
): string => {
  return globalEffectVariableMapping[effectId] || fallback;
};

const generateModJson = (metadata: ModMetadata): string => {
  const modJson: Record<string, unknown> = {
    id: metadata.id,
    name: metadata.name,
    author: metadata.author,
    description: metadata.description,
    prefix: metadata.prefix,
    main_file: metadata.main_file,
    version: metadata.version,
    priority: metadata.priority,
    badge_colour: metadata.badge_colour,
    badge_text_colour: metadata.badge_text_colour,
  };

  if (metadata.display_name && metadata.display_name !== metadata.name) {
    modJson.display_name = metadata.display_name;
  }

  if (metadata.dependencies && metadata.dependencies.length > 0) {
    modJson.dependencies = metadata.dependencies;
  }

  if (metadata.conflicts && metadata.conflicts.length > 0) {
    modJson.conflicts = metadata.conflicts;
  }

  if (metadata.provides && metadata.provides.length > 0) {
    modJson.provides = metadata.provides;
  }

  if (metadata.dump_loc) {
    modJson.dump_loc = metadata.dump_loc;
  }

  return JSON.stringify(modJson, null, 2);
};
